
---

## 🔐 Preconfigured Security — Fixes

- Fix typo: `"Unathorized"` → `"Unauthorized"`
- Clarify and simplify this sentence:

> Let's send the request again and provide with auth credentials generated by Spring

**Suggested:**
> Now, send the request again — this time using the default credentials shown in the console.

---

## ✅ Recap Section — Suggested Tweak

Right now, your recap repeats some earlier points and includes a confusing sentence:

> *In the next part of this series, we'll store users in a PostgreSQL database...* — but that’s **already covered** in this part.

### 🔄 Suggested Recap:

```markdown
---

## ✅ Recap — What We Covered

In this tutorial, we:

- Understood the internal authentication flow of Spring Security
- Set up PostgreSQL tables for `users`, `authorities`, and `users_authorities`
- Created JPA entities to map to those tables
- Implemented a custom `UserDetailsService` and mapped to `UserEntity`
- Logged the authenticated user and their authorities

Now, Spring Security can authenticate users by fetching their credentials and roles from a real database — just like in a production-ready app. 🚀

---

## 👉 What's Next?

In the next part of this series, we’ll go one step further and secure our endpoints using **JWT (JSON Web Token)** for stateless authentication.

Until then, feel free to ⭐️, share, or drop your thoughts in the comments!
